// MAKE SURE TO NAME PUT YOUR SHADER IN "shaders/<YOUR_GITHUB_USERNAME>"
// and make sure the filename ends in .frag
// for example, if your username is "hypnodroid", and you want to publish "my-shader.frag", the filename should be "hypnodroid/my-shader.frag"
#define EPSILON 0.001
// Use a linear time offset for continuous evolution
#define PROBE_1 (iTime * 0.1)
#define PROBE_2 1.
#define PROBE_3 0.4
#define PROBE_4 0.5
#define PROBE_6 (1./10.)

// Simple rotate function
vec2 rotate(vec2 uv, float angle) {
    float c = cos(angle);
    float s = sin(angle);
    return vec2(c * uv.x - s * uv.y, s * uv.x + c * uv.y);
}

// Instead of wrapping with fract(), add a continuously increasing phase offset inside sin()
vec2 applyPeriodicTransformationAndTraps(vec2 position, vec2 multiplier, vec2 uv) {
    float dotVal = max(dot(position, position), 0.001);
    vec2 tmp = multiplier * position / dotVal * PROBE_6;
    // Adding iTime*0.1 here ensures the transformation evolves forward over time.
    position = 0.5 * (sin(tmp + iTime * 0.1) - 0.2);
    return position;
}

void mainImage(out vec4 fragColor, in vec2 fragCoord) {
    // Center the UV coordinates (assuming centerUv() maps fragCoord to [0,1])
    vec2 uv = centerUv(fragCoord) - 0.5;
    
    // Start with a high value so we can use min() in the loop
    fragColor += 1e6 - fragColor;
    // Use the continuously evolving PROBE_1
    vec2 multiplier = vec2(PROBE_1, PROBE_2);
    
    for (int i = 0; i < 5; i++) {
        uv = applyPeriodicTransformationAndTraps(uv, multiplier, uv);
        
        float lengthTrap = length(uv);
        float minAxesTrap = min(abs(uv.x), abs(uv.y));
        float diagonalDotTrap = abs(dot(uv, vec2(0., PROBE_4)));
        
        fragColor = min(fragColor, vec4(lengthTrap, minAxesTrap, diagonalDotTrap, 1.0));
        vec3 hslColor = rgb2hsl(fragColor.rgb);
        hslColor.x = fract(hslColor.x + sin(iTime / 10000.0));
        hslColor.z = clamp(hslColor.z, 0., 0.5);
        fragColor.rgb = hsl2rgb(hslColor);
    }
}
