// @fullscreen: true
//http://localhost:6969/edit.html?knob_5=7.583&knob_5.min=0&knob_5.max=10.7&knob_6=1.257&knob_6.min=0&knob_6.max=8.4&knob_7=0.198&knob_7.min=0&knob_7.max=0.6&knob_17=3.928&knob_17.min=0&knob_17.max=4.3&knob_18=0.228&knob_18.min=0&knob_18.max=1&knob_13=0.559&knob_13.min=0&knob_13.max=1&knob_14=11.024&knob_14.min=0&knob_14.max=11.2&knob_8=0&knob_8.min=0&knob_8.max=1&knob_21=1&knob_21.min=0&knob_21.max=1&knob_4=0.63&knob_4.min=0&knob_4.max=1&knob_2=0.291&knob_2.min=0&knob_2.max=1&knob_19=0.866&knob_19.min=0&knob_19.max=10&knob_13=3.583&knob_13.min=0&knob_13.max=11.1&knob_14=2.796&knob_14.min=0&knob_14.max=5.3&knob_3=1&knob_3.min=0&knob_3.max=1&knob_15=0.591&knob_15.min=0&knob_15.max=1&knob_10=0&knob_10.min=0&knob_10.max=1&knob_11=0&knob_11.min=0&knob_11.max=1&knob_20=0.795&knob_20.min=0&knob_20.max=1&knob_16=0.469&knob_16.min=0&knob_16.max=11.9
//http://localhost:6969/edit.html?knob_5=0.59&knob_5.min=0&knob_5.max=10.7&knob_6=0&knob_6.min=0&knob_6.max=19.2&knob_7=0.397&knob_7.min=0&knob_7.max=0.6&knob_17=3.487&knob_17.min=0&knob_17.max=4.3&knob_18=0.717&knob_18.min=0&knob_18.max=1&knob_13=0.583&knob_13.min=0&knob_13.max=1&knob_14=1.676&knob_14.min=0&knob_14.max=11.2&knob_8=1&knob_8.min=0&knob_8.max=1&knob_21=1&knob_21.min=0&knob_21.max=1&knob_4=0.496&knob_4.min=0&knob_4.max=1&knob_2=0.417&knob_2.min=0&knob_2.max=1&knob_19=34.3&knob_19.min=0&knob_19.max=34.3&knob_13=5.943&knob_13.min=0&knob_13.max=11.1&knob_14=1.878&knob_14.min=0&knob_14.max=5.3&knob_3=1&knob_3.min=0&knob_3.max=1&knob_15=0.583&knob_15.min=0&knob_15.max=1&knob_10=0&knob_10.min=0&knob_10.max=1&knob_11=0&knob_11.min=0&knob_11.max=1&knob_20=0.866&knob_20.min=0&knob_20.max=1&knob_16=5.528&knob_16.min=0&knob_16.max=11.9&knob_9=0&knob_9.min=0&knob_9.max=1
//http://localhost:6969/edit.html?knob_5=-0.48&knob_5.min=-1&knob_5.max=1&knob_6=-0.228&knob_6.min=-1&knob_6.max=1&knob_7=0.085&knob_7.min=0&knob_7.max=0.6&knob_17=0.609&knob_17.min=0&knob_17.max=4.3&knob_18=0.559&knob_18.min=0&knob_18.max=1&knob_13=0.85&knob_13.min=0&knob_13.max=1&knob_14=11.2&knob_14.min=0&knob_14.max=11.2&knob_8=0.819&knob_8.min=0&knob_8.max=1&knob_21=0.74&knob_21.min=0&knob_21.max=1&knob_4=0.409&knob_4.min=0&knob_4.max=1&knob_2=0.339&knob_2.min=0&knob_2.max=1&knob_19=4.861&knob_19.min=0&knob_19.max=34.3&knob_13=2.972&knob_13.min=0&knob_13.max=11.1&knob_14=1.586&knob_14.min=0&knob_14.max=5.3&knob_3=0.031&knob_3.min=0.01&knob_3.max=1&knob_15=0.52&knob_15.min=0&knob_15.max=1&knob_10=0&knob_10.min=0&knob_10.max=1&knob_11=0&knob_11.min=0&knob_11.max=1&knob_20=0.622&knob_20.min=0&knob_20.max=1&knob_16=4.31&knob_16.min=0&knob_16.max=11.9&knob_9=0&knob_9.min=0&knob_9.max=1&knob_22=0&knob_22.min=0&knob_22.max=1&knob_24=0&knob_24.min=0&knob_24.max=1&knob_23=0&knob_23.min=0&knob_23.max=1&knob_12=0.433&knob_12.min=0&knob_12.max=1&knob_1=0&knob_1.min=0&knob_1.max=1

// http://localhost:6969/edit.html?knob_5.min=-1&knob_5.max=1&knob_6=0.22&knob_6.min=-1&knob_6.max=1&knob_13=0.88&knob_13.min=0&knob_13.max=1&knob_14=8.961&knob_14.min=0&knob_14.max=10.3&knob_15=0.51&knob_15.min=0&knob_15.max=3&knob_16=1.372&knob_16.min=0.1&knob_16.max=2.5&knob_18=0.55&knob_18.min=0&knob_18.max=1&knob_17=2.072&knob_17.min=0&knob_17.max=2.8&knob_19=3.169&knob_19.min=0.1&knob_19.max=3.2&knob_20=2.476&knob_20.min=0.1&knob_20.max=10&knob_21=0.55&knob_21.min=0&knob_21.max=1&knob_5=0.1

// Constants
#define MAX_RIPPLES 12
#define PI 3.14159265359
#define TIME (iTime/10.)
#define BEAT knob_9 > 0.50

// Audio reactive parameters
#define WAVE_SPEED knob_13
#define PATTERN_SCALE knob_14
#define RIPPLE_CHAOS knob_15      // How randomly ripples are placed
#define RIPPLE_SPREAD knob_15      // How far from center ripples appear
#define RIPPLE_STRENGTH knob_20      // How strong ripples are
#define COLOR_SHIFT knob_21       // Base color shift
#define BEAT_INTENSITY knob_20

// Ripple characteristics
#define RIPPLE_SPEED knob_14
#define RIPPLE_THICKNESS mapValue(knob_16, 0., 1., 0., sin(time/1000.))
#define RIPPLE_DISTANCE_DECAY knob_17
#define RIPPLE_AGE_DECAY mapValue(knob_4, -1.,1., knob_5, knob_6)
#define RIPPLE_BIRTH_STAGGER knob_7
#define RIPPLE_LIFE_DURATION knob_16
#define RIPPLE_BASE_STRENGTH knob_19

// Color and blending
#define COLOR_PERSISTENCE knob_13
#define COLOR_SATURATION knob_18
#define COLOR_BRIGHTNESS_SCALE knob_18


// Knob controls
uniform float knob_5;
uniform float knob_6;
uniform float knob_7;
uniform float knob_17;
uniform float knob_18;
uniform float knob_13;
uniform float knob_14;
uniform float knob_8;
uniform float knob_19;
uniform float knob_9;

uniform float knob_15;

uniform float knob_3;
uniform float knob_21;
uniform float knob_20;
uniform float knob_16;
uniform float knob_4;
// Ripple structure
struct Ripple {
    vec2 center;
    float birth;
    float strength;
};

// Better random function
float random(float seed) {
    return random(vec2(0.));
}

// 2D random
vec2 random2(float seed) {
    return vec2(
        random(seed),
        random(seed + 1234.5678)
    );
}

float createRipple(vec2 p, Ripple r) {
    float d = length(p - r.center);
    float age = TIME - r.birth;

    float radius = age * RIPPLE_SPEED;
    float thickness = RIPPLE_THICKNESS * 0.04;
    float wave = exp(-thickness * pow(d - radius, 2.0));

    float distanceDecay = exp(-d * RIPPLE_DISTANCE_DECAY);
    float ageDecay = exp(-age * RIPPLE_AGE_DECAY);

    return wave * distanceDecay * ageDecay * r.strength * RIPPLE_STRENGTH;
}

Ripple[MAX_RIPPLES] getRipples() {
    Ripple[MAX_RIPPLES] ripples;

    for(int i = 0; i < MAX_RIPPLES; i++) {
        float birthOffset = mod(TIME + float(i) * RIPPLE_BIRTH_STAGGER, RIPPLE_LIFE_DURATION);

        float angle = float(i) * PI * 2.0 / float(MAX_RIPPLES) + RIPPLE_CHAOS * PI;
        vec2 pos = vec2(cos(angle), sin(angle)) * RIPPLE_SPREAD;

        ripples[i] = Ripple(pos, TIME - birthOffset, RIPPLE_BASE_STRENGTH);
    }
    return ripples;
}

vec2 getWaveDistortion(vec2 uv) {
    float distortionX = sin(uv.y * PATTERN_SCALE * 4.0 + TIME * WAVE_SPEED) * 0.003;
    float distortionY = cos(uv.x * PATTERN_SCALE * 4.0 + TIME * WAVE_SPEED) * 0.003;
    return vec2(distortionX, distortionY);
}

void mainImage(out vec4 fragColor, in vec2 fragCoord) {
    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / min(iResolution.x, iResolution.y);
    vec2 texUV = fragCoord.xy / iResolution.xy;

    // Calculate ripple effect
    Ripple[MAX_RIPPLES] ripples = getRipples();
    float totalWave = 0.0;
    for(int i = 0; i < MAX_RIPPLES; i++) {
        totalWave += createRipple(uv, ripples[i]);
    }

    float interference = pow(abs(totalWave), 0.8);

    // Enhanced wave distortion
    vec2 distortion = getWaveDistortion(uv);
    vec2 p = uv + distortion * (2.0 + interference * 3.0); // Increased distortion effect

    // Apply wave distortion to sampling coordinates
    vec2 distortedUV = texUV;
    distortedUV += distortion * (1.0 + interference * 2.0);

    // Create more dynamic flow based on ripples
    vec2 rippleFlow = vec2(0.0);
    for(int i = 0; i < MAX_RIPPLES; i++) {
        vec2 toCenter = uv - ripples[i].center;
        float dist = length(toCenter);
        float age = TIME - ripples[i].birth;
        float strength = exp(-dist * RIPPLE_DISTANCE_DECAY) * exp(-age * RIPPLE_AGE_DECAY);
        rippleFlow += normalize(toCenter) * strength * 0.01;
    }

    // Combine wave distortion with ripple flow
    vec2 finalOffset = distortion + rippleFlow * interference;
    vec2 sampleUV = fract(texUV + finalOffset * 0.4);
    vec4 prevColor = getLastFrameColor(sampleUV);

    // Create plasma-like base color
    float v1 = sin(p.x * 3.0 + TIME * WAVE_SPEED);
    float v2 = sin(p.y * 3.0 + TIME * WAVE_SPEED * 0.8);
    float v3 = sin((p.x + p.y) * 2.0 + TIME * WAVE_SPEED * 1.2);
    float v4 = sin(length(p) * 4.0 - TIME * WAVE_SPEED);

    float plasma = (v1 + v2 + v3 + v4) * 0.25;
    plasma = plasma * 0.5 + 0.5;

    // Add stronger ripple influence
    plasma += interference * knob_17;
    plasma = plasma * 0.5 + 0.25;

    // Create base color from plasma
    vec3 baseHSL = fract(vec3(
        fract(plasma + COLOR_SHIFT),
        COLOR_SATURATION,
        0.5 + interference * 0.5  // Increased interference influence
    ));

    // Enhanced beat response
    if(BEAT) {
        vec2 beatPos = vec2(
            cos(RIPPLE_CHAOS * PI) * 0.3,
            sin(WAVE_SPEED * PI) * 0.3
        );
        float beatRipple = createRipple(uv, Ripple(beatPos, TIME, 2.0));
        baseHSL.x = fract(baseHSL.x + beatRipple * 0.2);
        baseHSL.z = fract(baseHSL.z + beatRipple * BEAT_INTENSITY);

        // Add extra wave distortion during beats
        p += beatRipple * distortion * 2.0;
    }

    vec3 baseColor = hsl2rgb(baseHSL);

    // Add depth variation based on wave pattern
    float depth = sin(length(p) * 3.0 - TIME) * 0.5 + 0.5;
    baseColor *= 0.8 + depth * 0.4;

    // Enhanced wave pattern visibility through color modulation
    float wavePattern = sin(totalWave * 5.0) * 0.5 + 0.5;
    baseColor *= 0.8 + wavePattern * 0.4;
    baseColor = fract(baseColor);
    // Blend with previous frame for smooth trails
    float trailStrength = 0.7 + interference * 0.02; // Dynamic trail strength
    vec3 color = hslmix(baseColor, prevColor.rgb, trailStrength);
    color = mix(color, prevColor.rgb, knob_6);
    // Apply vignette
    float vignette = smoothstep(1.1, 0.3, length(uv));
    // color *= vignette;

    // Ensure colors stay in valid range
    fragColor = vec4(fract(color), 1.0);
}
