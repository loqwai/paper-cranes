// @fullscreen: true
//http://localhost:6969/edit.html?knob_12=7.583&knob_12.min=0&knob_12.max=10.7&knob_13=1.257&knob_13.min=0&knob_13.max=8.4&knob_14=0.198&knob_14.min=0&knob_14.max=0.6&knob_15=3.928&knob_15.min=0&knob_15.max=4.3&knob_16=PROBE_B28&knob_16.min=0&knob_16.max=1&knob_17=0.559&knob_17.min=0&knob_17.max=1&knob_18=11.024&knob_18.min=0&knob_18.max=11.2&knob_19=0&knob_19.min=0&knob_19.max=1&knob_8=1&knob_8.min=0&knob_8.max=1&knob_11=0.63&knob_11.min=0&knob_11.max=1&knob_6=PROBE_B91&knob_6.min=0&knob_6.max=1&knob_20=0.866&knob_20.min=0&knob_20.max=10&knob_3=3.583&knob_3.min=0&knob_3.max=11.1&knob_4=2.796&knob_4.min=0&knob_4.max=5.3&knob_7=1&knob_7.min=0&knob_7.max=1&knob_5=0.591&knob_5.min=0&knob_5.max=1&knob_24=0&knob_24.min=0&knob_24.max=1&knob_25=0&knob_25.min=0&knob_25.max=1&knob_9=0.795&knob_9.min=0&knob_9.max=1&knob_10=0.469&knob_10.min=0&knob_10.max=11.9
//http://localhost:6969/edit.html?knob_12=0.59&knob_12.min=0&knob_12.max=10.7&knob_13=0&knob_13.min=0&knob_13.max=19.2&knob_14=0.397&knob_14.min=0&knob_14.max=0.6&knob_15=3.487&knob_15.min=0&knob_15.max=4.3&knob_16=0.717&knob_16.min=0&knob_16.max=1&knob_17=0.583&knob_17.min=0&knob_17.max=1&knob_18=1.676&knob_18.min=0&knob_18.max=11.2&knob_19=1&knob_19.min=0&knob_19.max=1&knob_8=1&knob_8.min=0&knob_8.max=1&knob_11=0.496&knob_11.min=0&knob_11.max=1&knob_6=0.417&knob_6.min=0&knob_6.max=1&knob_20=34.3&knob_20.min=0&knob_20.max=34.3&knob_3=5.943&knob_3.min=0&knob_3.max=11.1&knob_4=1.878&knob_4.min=0&knob_4.max=5.3&knob_7=1&knob_7.min=0&knob_7.max=1&knob_5=0.583&knob_5.min=0&knob_5.max=1&knob_24=0&knob_24.min=0&knob_24.max=1&knob_25=0&knob_25.min=0&knob_25.max=1&knob_9=0.866&knob_9.min=0&knob_9.max=1&knob_10=5.528&knob_10.min=0&knob_10.max=11.9&knob_21=0&knob_21.min=0&knob_21.max=1
//https://visuals.beadfamous.com/edit?knob_12=1&knob_12.min=0&knob_12.max=1&knob_13=1.101&knob_13.min=-1&knob_13.max=8.2&knob_14=0.529&knob_14.min=0&knob_14.max=3.2&knob_15=20.1&knob_15.min=0&knob_15.max=20.1&knob_16=0.346&knob_16.min=0&knob_16.max=1&knob_17=1.669&knob_17.min=-2.3&knob_17.max=4.9&knob_18=23.872&knob_18.min=0&knob_18.max=32.6&knob_19=0.74&knob_19.min=0&knob_19.max=1&knob_8=0.362&knob_8.min=0&knob_8.max=1&knob_11=0.447&knob_11.min=0&knob_11.max=0.8&knob_6=0.346&knob_6.min=0&knob_6.max=1&knob_20=24.994&knob_20.min=0&knob_20.max=53.8&knob_3=7.517&knob_3.min=0&knob_3.max=11.1&knob_4=0.118&knob_4.min=0&knob_4.max=1&knob_7=0.265&knob_7.min=0.01&knob_7.max=0.5&knob_5=2.055&knob_5.min=0&knob_5.max=14.5&knob_24=0&knob_24.min=0&knob_24.max=1&knob_25=0.49&knob_25.min=0&knob_25.max=1&knob_9=0.535&knob_9.min=0&knob_9.max=1&knob_10=0.482&knob_10.min=0&knob_10.max=5.1&knob_21=0&knob_21.min=0&knob_21.max=1&knob_29=0.37&knob_29.min=0&knob_29.max=1&knob_31=0&knob_31.min=0&knob_31.max=1&knob_30=0&knob_30.min=0&knob_30.max=1&knob_33=0.403&knob_33.min=0&knob_33.max=6.4&knob_1=0&knob_1.min=0&knob_1.max=1&knob_26=0&knob_26.min=0&knob_26.max=1&knob_35=0&knob_35.min=0&knob_35.max=1&knob_34=0&knob_34.min=0&knob_34.max=1&knob_32=0&knob_32.min=0&knob_32.max=1&knob_2=0&knob_2.min=0&knob_2.max=1&knob_28=0&knob_28.min=0&knob_28.max=1&knob_22=0&knob_22.min=0&knob_22.max=1&knob_27=0&knob_27.min=0&knob_27.max=1&knob_23=0&knob_23.min=0&knob_23.max=1
// Constants
#define MAX_RIPPLES 12
#define PI 3.14159265359
#define TIME (iTime/1000.)
#define BEAT knob_21 > .5

// Audio reactive parameters
#define WAVE_SPEED knob_3
#define PATTERN_SCALE 2.
#define RIPPLE_CHAOS knob_5      // How randomly ripples are placed
#define RIPPLE_SPREAD knob_6      // How far from center ripples appear
#define RIPPLE_STRENGTH knob_7      // How strong ripples are
#define COLOR_SHIFT knob_8       // Base color shift
#define BEAT_INTENSITY knob_9

// Ripple characteristics
#define RIPPLE_SPEED knob_18
#define RIPPLE_THICKNESS knob_33
#define RIPPLE_DISTANCE_DECAY knob_15
#define RIPPLE_AGE_DECAY knob_9
#define RIPPLE_BIRTH_STAGGER knob_14
#define RIPPLE_LIFE_DURATION knob_10
#define RIPPLE_BASE_STRENGTH knob_20

// Color and blending
#define COLOR_PERSISTENCE knob_17
#define COLOR_SATURATION knob_19
#define COLOR_BRIGHTNESS_SCALE knob_16
#define COLOR_MAX_DIFF knob_4

#define PROBE_A knob_12
#define PROBE_B knob_13
#define PROBE_C knob_33
// Knob controls
uniform float knob_12;
uniform float knob_13;
uniform float knob_14;
uniform float knob_15;
uniform float knob_16;
uniform float knob_17;
uniform float knob_18;
uniform float knob_19;
uniform float knob_20;
uniform float knob_21;

uniform float knob_3;
uniform float knob_4;
uniform float knob_5;
uniform float knob_6;
uniform float knob_7;
uniform float knob_8;
uniform float knob_9;
uniform float knob_10;
uniform float knob_11;
uniform float knob_34;
uniform float knob_33;
// Ripple structure
struct Ripple {
    vec2 center;
    float birth;
    float strength;
};

float createRipple(vec2 p, Ripple r) {
    float d = length(p - r.center);
    float age = TIME - r.birth;

    float radius = age * RIPPLE_SPEED;
    float thickness = RIPPLE_THICKNESS * 0.04;
    float wave = exp(-thickness * pow(d - radius, 2.0));

    float distanceDecay = exp(-d * RIPPLE_DISTANCE_DECAY);
    float ageDecay = exp(-age * RIPPLE_AGE_DECAY);

    return wave * distanceDecay * ageDecay * r.strength * RIPPLE_STRENGTH;
}

Ripple[MAX_RIPPLES] getRipples() {
    Ripple[MAX_RIPPLES] ripples;

    for(int i = 0; i < MAX_RIPPLES; i++) {
        float birthOffset = mod(TIME + float(i) * RIPPLE_BIRTH_STAGGER, RIPPLE_LIFE_DURATION);

        float angle = float(i) * PI * 2.0 / float(MAX_RIPPLES) * RIPPLE_CHAOS * PI;
        vec2 pos = vec2(cos(angle), sin(angle)) * RIPPLE_SPREAD;

        ripples[i] = Ripple(pos, TIME - birthOffset, RIPPLE_BASE_STRENGTH);
    }
    return ripples;
}

vec2 getWaveDistortion(vec2 uv) {
    float distortionX = sin(uv.y * PATTERN_SCALE * 4.0 + TIME * WAVE_SPEED) * 0.003;
    float distortionY = cos(uv.x * PATTERN_SCALE * 4.0 + TIME * WAVE_SPEED) * 0.003;
    return vec2(distortionX, distortionY);
}

void mainImage(out vec4 fragColor, in vec2 fragCoord) {
    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / min(iResolution.x, iResolution.y);
    // uv.x += 0.5;
    vec2 texUV = fragCoord.xy / iResolution.xy;

    vec4 prevColor = getLastFrameColor(texUV);
    vec3 prevHSL = rgb2hsl(prevColor.rgb);

    Ripple[MAX_RIPPLES] ripples = getRipples();

    float totalWave = 0.0;
    for(int i = 0; i < MAX_RIPPLES; i++) {
        totalWave += createRipple(uv, ripples[i]);
    }

    float interference = pow(abs(totalWave), PROBE_A);
    float brightness = smoothstep(0.1, 0.3, interference);

    vec2 flowOffset = normalize(uv) * interference * 0.001;
    vec4 offsetColor = getLastFrameColor(texUV + flowOffset);
    vec3 offsetHSL = rgb2hsl(offsetColor.rgb);

    vec3 newColorHSL = vec3(
        fract(offsetHSL.x + interference * PROBE_B + COLOR_SHIFT),
        COLOR_SATURATION,
        brightness * COLOR_BRIGHTNESS_SCALE
    );

    if(BEAT) {
        vec2 beatPos = vec2(
            cos(RIPPLE_CHAOS * PI) * 0.3,
            sin(WAVE_SPEED * PI) * 0.3
        );
        float beatRipple = createRipple(uv, Ripple(beatPos, TIME, 2.0));
        newColorHSL.x = fract(newColorHSL.x + beatRipple * PROBE_B);
        newColorHSL.z = min(1.0, newColorHSL.z + beatRipple * BEAT_INTENSITY);
    }

    float blendFactor = PROBE_A;
    vec3 blendedHSL;

    if(brightness > 0.1) {
        blendedHSL = vec3(
            fract(mix(prevHSL.x, newColorHSL.x, blendFactor)),
            COLOR_SATURATION,
            mix(prevHSL.z * COLOR_PERSISTENCE, newColorHSL.z, blendFactor)
        );
    } else {
        blendedHSL = vec3(
            prevHSL.x,
            max(0.0, prevHSL.y - 0.1),
            prevHSL.z * COLOR_PERSISTENCE * 0.95
        );
    }

    float colorDiff = abs(blendedHSL.x - prevHSL.x);
    if(colorDiff > COLOR_MAX_DIFF && knob_34 < 0.2) {
        blendedHSL = mix(prevHSL, blendedHSL, colorDiff/10.);
        blendedHSL.z *= 0.9;
    }
    if(knob_34 > 0.5) {
      blendedHSL.x = fract(blendedHSL.x + 0.1);
    }

    vec3 finalColor = hsl2rgb(blendedHSL);

    float vignette = smoothstep(1.1, 0.3, length(uv));
    finalColor *= vignette;
    finalColor *= smoothstep(0.05, 0.1, brightness);


    fragColor = vec4(finalColor, 1.0);
}
